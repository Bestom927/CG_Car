<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="format-detection" content="telephone=no">
    <title>Car</title>
    <style>
        html, body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="./js/three.js"></script>
    <script src="./js/OBJLoader.js"></script>
    <script src="./js/MTLLoader.js"></script>
    <script src="./js/outside.js"></script>
    <script src="./js/car.js"></script>
    <script type="module">
        var scene = new THREE.Scene();  
  
        var camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 1000);

        camera.position.z = 0;
        camera.position.x = 0;
        camera.speed = {
            z: 0,
            x: 0
        };
        
        var webGLRenderer = new THREE.WebGLRenderer();

        webGLRenderer.setPixelRatio(window.devicePixelRatio);
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.setClearColor(0x0077ec, 1);
        webGLRenderer.shadowMap.enabled = true;
        webGLRenderer.shadowMap.type = THREE.PCFShadowMap;

        
        var pointLight = new THREE.PointLight(0xccbbaa, 1, 0, 0);  
        pointLight.position.set(-10, 20, -20);
        pointLight.castShadow = true;

        scene.add(pointLight);

        
        var light = new THREE.AmbientLight( 0xccbbaa, 0.1 );
        scene.add( light );

        /*var dirLight = new THREE.DirectionalLight(0xccbbaa, 0.5, 100);
        dirLight.position.set(-120, 500, -0);
        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 1000;
        dirLight.shadow.mapSize.height = 1000;

        dirLight.shadow.camera.near = 2;
        dirLight.shadow.camera.far = 1000;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;

        scene.add(dirLight);*/

        //创建一千个随机物体
        //var geometry = new THREE.BoxBufferGeometry(20,20,20)
        var geometrys = [
            new THREE.BoxBufferGeometry(20, 20, 20),
            new THREE.TorusBufferGeometry(10, 3, 16, 100),
            new THREE.CylinderBufferGeometry(10, 10, 20, 32),
            new THREE.ConeBufferGeometry(10, 20, 32),
            new THREE.IcosahedronBufferGeometry(10, 0)
        ]
        var material = new THREE.MeshStandardMaterial({color:new THREE.Color(0.4,0.4,0.4),side:2})

        var items=[];
        var spheres=[];
        //使用three随机创建一千个物体并存到spheres数组?
        for(var i=0;i<1000;i++){
            var geometry=geometrys[Math.floor(Math.random()*geometrys.length)]
            var instanceMesh = new THREEE.InstancedMesh(geometry,material,1000)
            var mesh = new THREEE.Mesh(geometry,material)
            mesh.position.x = (Math.random() - 0.5) * 1000;
            mesh.position.y = (Math.random() - 0.5) * 1000;
            mesh.position.z = (Math.random() - 0.5) * 1000;
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;
            mesh.scale.x = Math.random() + 0.5;
            mesh.scale.y = Math.random() + 0.5;
            mesh.scale.z = Math.random() + 0.5;
            
            mesh.geometry.computeBoundingSphere()
            var boundingSphere = mesh.geometry.boundingSphere.clone()
            spheres.push(boundingSphere)
            let r=500
            let fai=1*3.14*Math.random()
            let lamda=2*3.14*Math.random()
            var matrix = new THREEE.Matrix4().set(
                2*Math.random()-1,2*Math.random()-1,2*Math.random()-1,r*Math.cos(lamda)*Math.sin(fai),
                2*Math.random()-1,2*Math.random()-1,2*Math.random()-1,r*Math.sin(lamda)*Math.sin(fai),
                2*Math.random()-1,2*Math.random()-1,2*Math.random()-1,r*Math.cos(fai),
                0,0,0,1
            )
            instanceMesh.setMatrixAt(i,matrix)
            instanceMesh.setColorAt(i,new THREE.Color(Math.random(),Math.random(),Math.random()))
            mesh.applyMatrix4(matrix)
            boundingSphere.applyMatrix4(matrix)
            // mesh.castShadow = false;
            // mesh.receiveShadow = false;
            //this.scene.add(mesh)
            items.push(mesh)
            var sphere = new THREEE.Mesh(
                new THREEE.SphereBufferGeometry(boundingSphere.radius),
                material
            )
            sphere.position.copy(boundingSphere.center)

            spheres.push(boundingSphere);
            scene.add(mesh);
            
        }
        scene.add(instanceMesh)



        document.body.appendChild(webGLRenderer.domElement);

        


        document.body.addEventListener('keydown', function(e) {
            // console.log(e.keyCode);
            switch(e.keyCode) {
                case 87: // w
                    car.run = true;
                    break;
                case 65: // a
                    car.rSpeed = 0.02;
                    break;
                case 68: // d
                    car.rSpeed = -0.02;
                    break;
                case 32: // space
                    car.brake();
                    break;
            }
        });

        document.body.addEventListener('keyup', function(e) {
            switch(e.keyCode) {
                case 87: // w
                    car.run = false;
                    break;
                case 65: // a
                    car.rSpeed = 0;
                    break;
                case 68: // d
                    car.rSpeed = 0;
                    break;
                case 32: // space
                    car.cancelBrake();
                    break;
            }
        });

        var car = new Car({
            camera: camera,
            scene: scene,
            cb: start,
            light: pointLight
        });

        var ground;

        function start() {
            ground = new Ground({
                scene: scene
            });

            render();
        }
        
        function Ground() {
            var meshBasicMaterial = new THREE.MeshLambertMaterial({
                color: 0xff0000,
                side: THREE.DoubleSide
            });
            // 平面
            // var geometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            // var plane = new THREE.Mesh(geometry, meshBasicMaterial);
            // plane.rotation.x = -Math.PI / 2;
            // plane.position.y = -10;
            // plane.receiveShadow = true;

            // this.plane = plane;
            // scene.add(plane);

            // 赛道自制
        //     var mtlLoader = new THREE.MTLLoader();
        //     mtlLoader.setPath('./assets/');
        //     mtlLoader.load('brick.mtl', function (materials) {
        //     materials.side= THREE.DoubleSide;
        //     materials.preload();
        //     var objLoader = new THREE.OBJLoader();
        //     objLoader.setMaterials(materials);
        //     objLoader.setPath('./assets/');
        //     objLoader.load('brick.obj', function(object) {
        //         object.children.forEach(function(item) {
        //             item.receiveShadow = true;
        //         });
        //         object.position.y = -5;

                
        //         scene.add(object);

        //     }, function() {
        //         console.log('progress');
        //     }, function() {
        //         console.log('error');
        //     });
        // });


        // 丑地图
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('./assets/');
        mtlLoader.load('ground.mtl', function (materials) {
        materials.side= THREE.DoubleSide;
        materials.preload();
        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath('./assets/');
        objLoader.load('ground.obj', function(object) {
            object.children.forEach(function(item) {
                item.receiveShadow = true;
            });
            object.position.y = -5;

            
            scene.add(object);

        }, function() {
            console.log('progress');
        }, function() {
            console.log('error');
        });
    });

            
        }

        function render() {  
            car.tick({
                camera: camera
            });

            requestAnimationFrame(render);
            
            webGLRenderer.render(scene, camera);
            frustumCullingForItems(scene, camera);
        }

        import * as THREEE from "/node_modules/three/build/three.module.js";
        function frustumCullingForItems(){
            var num = 0
            var frustum = new THREEE.Frustum()
                .setFromProjectionMatrix(new THREEE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse))
            for(let i=0; i<spheres.length; i++){
                var sphere = spheres[i]
                var intersect = true
                for(let j=0; j<frustum.planes.length; j++){
                    
                        var dis = pointToPlane(sphere.center,frustum.planes[j])
                        if(dis<-sphere.radius)
                            intersect = false
                }
                // 因为有可能items[i]是空的，所以要判断一下
                if(items[i]){
                    //console.log(items[i])
                    items[i].visible = intersect
                    if(intersect)
                        num++
                }
                // items[i].visible = intersect
                // if(intersect) num++
            }
            console.log(num)
        }
        function pointToPlane(point,plane){
            // console.log(plane.normal.x)
            var A = plane.normal.x
            var B = plane.normal.y
            var C = plane.normal.z
            var D = plane.constant
            // console.log(point.x)
            var dis = A*point.x+B*point.y+C*point.z+D
            return dis
        }
    </script>
</body>
</html>